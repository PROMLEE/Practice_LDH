def solve(A):
  n = len(A)
  S = [] # DP저장 리스트
  for i in range(0, n):
    S.append([0])
    for j in range(1, 201):
      if A[i] < j:
        x = j-A[i]
      else:
        x = A[i]-j
      if i == 0:
        S[i].append(x)
      else:
        if j == 1:
          y = S[i-1][1]
        else:
          y = min(S[i-1][1:j+1])
        S[i].append(y+x)
  return min(S[n-1][1:201])

A = [int(x) for x in input().split()]
print(solve(A))
#-------------------------------------
'''
1. solve(A) 함수 알고리즘 설명
  (1) 리스트 A의 첫번째(i = 0) 수가 j(1<= j <=200)가 되기 위한 증감 연산의 횟수(x)를
      S[0]에 차례로 저장한다.(S[i][0]은 0으로 고정)
  (2) 리스트 A의 두번째(i = 1) 수가 j(1<= j <=200)가 되기 위한 증감 연산자의 횟수와
      j이전에 j보다 작거나 같은 수만 올 수 있는 S[i-1][1:j+1]의 최솟값과의 합을
      S[1]에 차례로 저장한다.(S[i][0]은 0으로 고정)
  (3) 이처럼 A의 마지막 값까지 (2)를 반복한다면 S[a][b]에는 리스트 A[a]의 값을 b로 만들 때
      실행되는 증감 연산의 최소 횟수가 저장되어있다.
  (4) 리스트 A를 오름차순이 되도록 하는 증감 연산 최소 횟수는 S[n-1]의 최소 인수이다.
      (n = len(A), S[n-1][0] 제외)

2. solve(A) 함수 수행시간 분석
  (1) 1.(2)에서 상수 번의 연산 + S[0][k]의 최솟값을 구하는 과정에서 O(n) 소요
  (2) (1)의연산을 200회 실행 (상수번 실행)
  (3) (2)의 연산을 n회 실행
    T(n) = (k+n)*200*n -> O(n^2)
'''